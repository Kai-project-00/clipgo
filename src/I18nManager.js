class I18nManager {
    constructor() {
        this.currentLanguage = 'ko';
        this.translations = {};
        this.fallbackLanguage = 'en';
        this.initialized = false;
        this.eventListeners = {};
    }

    async initialize() {
        try {
            // 저장된 언어 설정 로드
            const result = await chrome.storage.local.get(['settings']);
            this.currentLanguage = result.settings?.language || this.detectBrowserLanguage();

            // 번역 파일 로드
            await this.loadTranslations();

            // DOM 업데이트
            this.updateDOM();

            // 이벤트 리스너 설정
            this.setupEventListeners();

            this.initialized = true;
            console.log('I18n system initialized with language:', this.currentLanguage);
        } catch (error) {
            console.error('Failed to initialize i18n:', error);
            this.currentLanguage = 'en'; // Fallback
        }
    }

    detectBrowserLanguage() {
        const browserLang = navigator.language.toLowerCase();
        return browserLang.startsWith('ko') ? 'ko' : 'en';
    }

    async loadTranslations() {
        try {
            // Chrome 확장 프로그램의 _locales 디렉토리에서 번역 파일 로드
            const [koTranslations, enTranslations] = await Promise.all([
                this.loadTranslationFile('ko'),
                this.loadTranslationFile('en')
            ]);

            this.translations = {
                ko: koTranslations,
                en: enTranslations
            };
        } catch (error) {
            console.error('Failed to load translations:', error);
            // Fallback으로 기본 번역 데이터 사용
            this.translations = this.getDefaultTranslations();
        }
    }

    async loadTranslationFile(lang) {
        try {
            // Chrome i18n API 사용
            const response = await fetch(`_locales/${lang}/messages.json`);
            if (!response.ok) {
                throw new Error(`Failed to load ${lang} translations`);
            }
            return await response.json();
        } catch (error) {
            console.warn(`Failed to load ${lang} translations, using fallback:`, error);
            return this.getFallbackTranslations(lang);
        }
    }

    getDefaultTranslations() {
        return {
            ko: {
                extensionName: "ClipGo",
                extensionDescription: "AI 대화 클립 저장 관리자",
                saveClip: "클립 저장",
                categories: "카테고리",
                allClips: "모든 클립",
                search: "검색",
                settings: "설정",
                language: "언어",
                theme: "테마",
                lightTheme: "라이트 모드",
                darkTheme: "다크 모드",
                noClips: "저장된 클립이 없습니다",
                clipSaved: "클립이 저장되었습니다",
                clipDeleted: "클립이 삭제되었습니다",
                categoryCreated: "카테고리가 생성되었습니다",
                categoryDeleted: "카테고리가 삭제되었습니다",
                selectTextToSave: "저장할 텍스트를 선택하세요",
                newCategory: "새 카테고리",
                editCategory: "카테고리 편집",
                deleteCategory: "카테고리 삭제",
                deleteConfirmation: "정말 삭제하시겠습니까?",
                cancel: "취소",
                confirm: "확인",
                dragToReorder: "드래그하여 순서 변경",
                copyToClipboard: "클립보드에 복사",
                editClip: "클립 편집",
                deleteClip: "클립 삭제",
                source: "출처",
                savedAt: "저장 시간",
                wordCount: "단어 수",
                characterCount: "글자 수",
                latestOrder: "최신순",
                oldestOrder: "오래된순",
                titleOrder: "제목순",
                categoryOrder: "카테고리순",
                searchCategories: "카테고리 검색...",
                searchClips: "클립 검색...",
                dragToCategorize: "카테고리에 드래그하여 분류",
                noCategories: "카테고리가 없습니다",
                createFirstCategory: "첫 번째 카테고리를 생성하세요!",
                organizeClipsWithCategories: "카테고리로 클립을 정리하세요",
                selectedText: "선택된 텍스트",
                title: "제목",
                tags: "태그",
                enterTagsCommaSeparated: "태그를 쉼표로 구분하여 입력하세요",
                autoGeneratedTitle: "자동 생성된 제목",
                saveClipButton: "클립 저장",
                cancelButton: "취소",
                noClipsYet: "아직 클립이 없습니다",
                dragTextFromChatGPT: "ChatGPT에서 텍스트를 드래그하여 첫 번째 클립을 저장하세요!",
                createYourFirstCategory: "첫 번째 카테고리를 생성하세요!",
                organizeYourClips: "사용자 정의 카테고리로 클립을 정리하세요"
            },
            en: {
                extensionName: "ClipGo",
                extensionDescription: "AI conversation clip manager",
                saveClip: "Save Clip",
                categories: "Categories",
                allClips: "All Clips",
                search: "Search",
                settings: "Settings",
                language: "Language",
                theme: "Theme",
                lightTheme: "Light Mode",
                darkTheme: "Dark Mode",
                noClips: "No clips saved yet",
                clipSaved: "Clip saved successfully",
                clipDeleted: "Clip deleted successfully",
                categoryCreated: "Category created successfully",
                categoryDeleted: "Category deleted successfully",
                selectTextToSave: "Select text to save",
                newCategory: "New Category",
                editCategory: "Edit Category",
                deleteCategory: "Delete Category",
                deleteConfirmation: "Are you sure you want to delete?",
                cancel: "Cancel",
                confirm: "Confirm",
                dragToReorder: "Drag to reorder",
                copyToClipboard: "Copy to clipboard",
                editClip: "Edit Clip",
                deleteClip: "Delete Clip",
                source: "Source",
                savedAt: "Saved at",
                wordCount: "Word count",
                characterCount: "Character count",
                latestOrder: "Latest",
                oldestOrder: "Oldest",
                titleOrder: "By Title",
                categoryOrder: "By Category",
                searchCategories: "Search categories...",
                searchClips: "Search clips...",
                dragToCategorize: "Drag to categorize",
                noCategories: "No categories",
                createFirstCategory: "Create your first category!",
                organizeClipsWithCategories: "Organize your clips with categories",
                selectedText: "Selected Text",
                title: "Title",
                tags: "Tags",
                enterTagsCommaSeparated: "Enter tags separated by commas",
                autoGeneratedTitle: "Auto-generated title",
                saveClipButton: "Save Clip",
                cancelButton: "Cancel",
                noClipsYet: "No clips yet",
                dragTextFromChatGPT: "Drag text from ChatGPT to save your first clip!",
                createYourFirstCategory: "Create your first category!",
                organizeYourClips: "Organize your clips with custom categories"
            }
        };
    }

    getFallbackTranslations(lang) {
        const defaults = this.getDefaultTranslations();
        return defaults[lang] || defaults.en;
    }

    async setLanguage(lang) {
        if (this.translations[lang]) {
            this.currentLanguage = lang;

            // 설정 저장
            const settings = await this.getSettings();
            await chrome.storage.local.set({
                settings: { ...settings, language: lang }
            });

            // DOM 업데이트
            this.updateDOM();

            // 이벤트 발생
            this.emit('languageChanged', { language: lang });
        }
    }

    translate(key, params = {}) {
        const translation = this.translations[this.currentLanguage]?.[key] ||
                          this.translations[this.fallbackLanguage]?.[key] ||
                          key;

        // 파라미터 치환
        return this.interpolate(translation, params);
    }

    interpolate(text, params) {
        if (typeof text !== 'string') return text;

        return text.replace(/\{\{(\w+)\}\}/g, (match, key) => {
            return params[key] !== undefined ? params[key] : match;
        });
    }

    updateDOM() {
        // data-i18n 속성이 있는 모든 요소 업데이트
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            const translation = this.translate(key);

            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                element.placeholder = translation;
            } else if (element.tagName === 'SELECT') {
                // 옵션 요소들은 개별적으로 처리
            } else {
                element.textContent = translation;
            }
        });

        // data-i18n-placeholder 속성이 있는 요소 업데이트
        document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
            const key = element.getAttribute('data-i18n-placeholder');
            element.placeholder = this.translate(key);
        });

        // data-i18n-title 속성이 있는 요소의 툴팁 업데이트
        document.querySelectorAll('[data-i18n-title]').forEach(element => {
            const key = element.getAttribute('data-i18n-title');
            element.title = this.translate(key);
        });

        // data-i18n-html 속성이 있는 요소의 HTML 업데이트
        document.querySelectorAll('[data-i18n-html]').forEach(element => {
            const key = element.getAttribute('data-i18n-html');
            element.innerHTML = this.translate(key);
        });

        // 옵션 요소들 업데이트
        document.querySelectorAll('option[data-i18n]').forEach(option => {
            const key = option.getAttribute('data-i18n');
            option.textContent = this.translate(key);
        });
    }

    setupEventListeners() {
        // 언어 선택 변경 감지
        const languageSelect = document.getElementById('language-select');
        if (languageSelect) {
            languageSelect.addEventListener('change', (e) => {
                this.setLanguage(e.target.value);
            });
        }
    }

    async getSettings() {
        const result = await chrome.storage.local.get(['settings']);
        return result.settings || {};
    }

    // 이벤트 리스너 관리
    on(event, callback) {
        if (!this.eventListeners[event]) {
            this.eventListeners[event] = [];
        }
        this.eventListeners[event].push(callback);
    }

    emit(event, data) {
        if (this.eventListeners[event]) {
            this.eventListeners[event].forEach(callback => callback(data));
        }

        // CustomEvent로도 발생
        const customEvent = new CustomEvent(event, { detail: data });
        document.dispatchEvent(customEvent);
    }
}

// Theme Manager 클래스
class ThemeManager {
    constructor(i18nManager) {
        this.i18nManager = i18nManager;
        this.currentTheme = 'light';
        this.initialized = false;
        this.eventListeners = {};
    }

    async initialize() {
        try {
            // 저장된 테마 설정 로드
            const result = await chrome.storage.local.get(['settings']);
            this.currentTheme = result.settings?.theme || this.detectPreferredTheme();

            // 테마 적용
            this.applyTheme();

            // 이벤트 리스너 설정
            this.setupEventListeners();

            this.initialized = true;
            console.log('Theme manager initialized with theme:', this.currentTheme);
        } catch (error) {
            console.error('Failed to initialize theme manager:', error);
        }
    }

    detectPreferredTheme() {
        // 사용자 시스템 설정 감지
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        return 'light';
    }

    applyTheme() {
        document.documentElement.setAttribute('data-theme', this.currentTheme);
        document.body.classList.toggle('dark-theme', this.currentTheme === 'dark');

        // OS 테마 변경 감지
        if (window.matchMedia) {
            const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            mediaQuery.addEventListener('change', (e) => {
                if (!this.hasUserThemePreference()) {
                    this.currentTheme = e.matches ? 'dark' : 'light';
                    this.applyTheme();
                }
            });
        }
    }

    async setTheme(theme) {
        this.currentTheme = theme;

        // 설정 저장
        const settings = await this.getSettings();
        await chrome.storage.local.set({
            settings: { ...settings, theme: theme }
        });

        // 테마 적용
        this.applyTheme();

        // 이벤트 발생
        this.emit('themeChanged', { theme });
    }

    setupEventListeners() {
        const themeSelect = document.getElementById('theme-select');
        if (themeSelect) {
            themeSelect.addEventListener('change', (e) => {
                this.setTheme(e.target.value);
            });
        }
    }

    async getSettings() {
        const result = await chrome.storage.local.get(['settings']);
        return result.settings || {};
    }

    hasUserThemePreference() {
        // 사용자가 직접 테마를 설정했는지 확인
        return localStorage.getItem('userThemePreference') === 'true';
    }

    on(event, callback) {
        if (!this.eventListeners[event]) {
            this.eventListeners[event] = [];
        }
        this.eventListeners[event].push(callback);
    }

    emit(event, data) {
        if (this.eventListeners[event]) {
            this.eventListeners[event].forEach(callback => callback(data));
        }

        const customEvent = new CustomEvent(event, { detail: data });
        document.dispatchEvent(customEvent);
    }
}

// 전역으로 export
window.I18nManager = I18nManager;
window.ThemeManager = ThemeManager;