<!DOCTYPE html>
<html>
<head>
    <title>ClipGo í™•ì¥ í”„ë¡œê·¸ë¨ ì§„ë‹¨ ë„êµ¬</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        .debug-section {
            border: 1px solid #ddd;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .test-text {
            background-color: #e8f4fd;
            padding: 15px;
            margin: 10px 0;
            border-radius: 3px;
            cursor: pointer;
            user-select: text;
            border-left: 4px solid #2196F3;
        }
        button {
            background-color: #2196F3;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #1976D2;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
            font-family: monospace;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .log-output {
            background-color: #263238;
            color: #fff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 3px;
            font-family: monospace;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .instructions {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .test-result {
            margin: 5px 0;
            padding: 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>ğŸ”§ ClipGo í™•ì¥ í”„ë¡œê·¸ë¨ ì§„ë‹¨ ë„êµ¬</h1>

    <div class="instructions">
        <h3>ğŸ“‹ ì§„ë‹¨ ìˆœì„œ</h3>
        <ol>
            <li><strong>Chrome í™•ì¥ í”„ë¡œê·¸ë¨ í™•ì¸</strong>: ì•„ë˜ "í™•ì¥ í”„ë¡œê·¸ë¨ ìƒíƒœ í™•ì¸" ë²„íŠ¼ í´ë¦­</li>
            <li><strong>ì½˜í…ì¸  ìŠ¤í¬ë¦½íŠ¸ í™•ì¸</strong>: "ì½˜í…ì¸  ìŠ¤í¬ë¦½íŠ¸ ì§„ë‹¨" ë²„íŠ¼ í´ë¦­</li>
            <li><strong>ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í…ŒìŠ¤íŠ¸</strong>: í…ìŠ¤íŠ¸ ë“œë˜ê·¸í•˜ì—¬ ì´ë²¤íŠ¸ ê°ì§€ í™•ì¸</li>
            <li><strong>Chrome API í…ŒìŠ¤íŠ¸</strong>: ë©”ì‹œì§• ê¸°ëŠ¥ í™•ì¸</li>
            <li><strong>ìˆ˜ë™ í…ŒìŠ¤íŠ¸</strong>: ì‹¤ì œ ì›¹ì‚¬ì´íŠ¸ì—ì„œ í…ŒìŠ¤íŠ¸</li>
        </ol>
    </div>

    <div class="debug-section">
        <h3>ğŸ” 1. í™•ì¥ í”„ë¡œê·¸ë¨ ìƒíƒœ í™•ì¸</h3>
        <button onclick="checkExtensionStatus()">í™•ì¥ í”„ë¡œê·¸ë¨ ìƒíƒœ í™•ì¸</button>
        <button onclick="checkChromeAPIs()">Chrome API í™•ì¸</button>
        <div id="extension-status"></div>
        <div id="api-status" class="log-output"></div>
    </div>

    <div class="debug-section">
        <h3>ğŸ“¦ 2. ì½˜í…ì¸  ìŠ¤í¬ë¦½íŠ¸ ì§„ë‹¨</h3>
        <button onclick="checkContentScript()">ì½˜í…ì¸  ìŠ¤í¬ë¦½íŠ¸ í™•ì¸</button>
        <button onclick="checkPopupManager()">PopupManager í™•ì¸</button>
        <button onclick="checkEventListeners()">ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í™•ì¸</button>
        <div id="content-script-status"></div>
    </div>

    <div class="debug-section">
        <h3>ğŸ¯ 3. ë“œë˜ê·¸ í…ŒìŠ¤íŠ¸</h3>
        <p>ì•„ë˜ í…ìŠ¤íŠ¸ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì„ íƒí•´ë³´ì„¸ìš”:</p>
        <div class="test-text" id="test-text-1">
            This is a test text for ClipGo drag functionality. Try selecting this text with your mouse to see if the popup appears.
        </div>
        <div class="test-text" id="test-text-2">
            Another test text for verifying the drag and drop functionality of the ClipGo extension. This should trigger the popup manager.
        </div>
        <button onclick="clearSelectionTestResults()">ì„ íƒ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì§€ìš°ê¸°</button>
        <div id="drag-test-results"></div>
    </div>

    <div class="debug-section">
        <h3>ğŸ”§ 4. ë©”ì‹œì§• í…ŒìŠ¤íŠ¸</h3>
        <button onclick="testMessageToBackground()">ë°±ê·¸ë¼ìš´ë“œ ë©”ì‹œì§€ í…ŒìŠ¤íŠ¸</button>
        <button onclick="testStorageAPI()">Storage API í…ŒìŠ¤íŠ¸</button>
        <button onclick="clearMessageResults()">ë©”ì‹œì§€ ê²°ê³¼ ì§€ìš°ê¸°</button>
        <div id="messaging-results"></div>
    </div>

    <div class="debug-section">
        <h3>ğŸ“Š 5. ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰</h3>
        <button onclick="runFullDiagnostic()">ì „ì²´ ì§„ë‹¨ ì‹¤í–‰</button>
        <button onclick="clearAllResults()">ëª¨ë“  ê²°ê³¼ ì§€ìš°ê¸°</button>
        <div id="full-diagnostic-results"></div>
    </div>

    <script>
        let debugLog = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            debugLog.push(logEntry);
            console.log(logEntry);
            return logEntry;
        }

        function updateElement(elementId, content, className = 'info') {
            const element = document.getElementById(elementId);
            if (element) {
                element.innerHTML += `<div class="${className}">${content}</div>`;
            }
        }

        function checkExtensionStatus() {
            const statusDiv = document.getElementById('extension-status');
            statusDiv.innerHTML = '<h4>í™•ì¥ í”„ë¡œê·¸ë¨ ìƒíƒœ</h4>';

            // Check if Chrome APIs are available
            const hasChrome = typeof chrome !== 'undefined';
            const hasRuntime = hasChrome && typeof chrome.runtime !== 'undefined';
            const hasStorage = hasChrome && typeof chrome.storage !== 'undefined';
            const hasTabs = hasChrome && typeof chrome.tabs !== 'undefined';

            updateElement('extension-status', `Chrome API ì ‘ê·¼: ${hasChrome ? 'âœ…' : 'âŒ'}`, hasChrome ? 'success' : 'error');
            updateElement('extension-status', `Runtime API: ${hasRuntime ? 'âœ…' : 'âŒ'}`, hasRuntime ? 'success' : 'error');
            updateElement('extension-status', `Storage API: ${hasStorage ? 'âœ…' : 'âŒ'}`, hasStorage ? 'success' : 'error');
            updateElement('extension-status', `Tabs API: ${hasTabs ? 'âœ…' : 'âŒ'}`, hasTabs ? 'success' : 'error');

            if (hasRuntime) {
                try {
                    // Test message sending to background script
                    chrome.runtime.sendMessage({ action: 'test' }, (response) => {
                        if (chrome.runtime.lastError) {
                            updateElement('extension-status', `ë°±ê·¸ë¼ìš´ë“œ ìŠ¤í¬ë¦½íŠ¸: âŒ ${chrome.runtime.lastError.message}`, 'error');
                        } else {
                            updateElement('extension-status', 'ë°±ê·¸ë¼ìš´ë“œ ìŠ¤í¬ë¦½íŠ¸: âœ…', 'success');
                        }
                    });
                } catch (error) {
                    updateElement('extension-status', `ë°±ê·¸ë¼ìš´ë“œ ìŠ¤í¬ë¦½íŠ¸ ì ‘ê·¼ ì˜¤ë¥˜: ${error.message}`, 'error');
                }
            }

            // Test Storage API
            if (hasStorage) {
                try {
                    chrome.storage.local.set({ test: 'value' }, () => {
                        if (chrome.runtime.lastError) {
                            updateElement('extension-status', `Storage API ë™ì‘: âŒ ${chrome.runtime.lastError.message}`, 'error');
                        } else {
                            updateElement('extension-status', 'Storage API ë™ì‘: âœ…', 'success');
                        }
                    });
                } catch (error) {
                    updateElement('extension-status', `Storage API í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜: ${error.message}`, 'error');
                }
            }

            // Test Tabs API
            if (hasTabs) {
                try {
                    chrome.tabs.query({ active: true }, (tabs) => {
                        if (chrome.runtime.lastError) {
                            updateElement('extension-status', `Tabs API ë™ì‘: âŒ ${chrome.runtime.lastError.message}`, 'error');
                        } else {
                            updateElement('extension-status', 'Tabs API ë™ì‘: âœ…', 'success');
                        }
                    });
                } catch (error) {
                    updateElement('extension-status', `Tabs API í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜: ${error.message}`, 'error');
                }
            }

            log('Extension status check completed');
        }

        function checkChromeAPIs() {
            const apiDiv = document.getElementById('api-status');
            apiDiv.innerHTML = '';

            const apiChecks = {
                chrome: typeof chrome,
                chrome_runtime: typeof chrome?.runtime,
                chrome_storage: typeof chrome?.storage,
                chrome_tabs: typeof chrome?.tabs,
                chrome_scripting: typeof chrome?.scripting,
                chrome_contextMenus: typeof chrome?.contextMenus
            };

            Object.entries(apiChecks).forEach(([api, type]) => {
                const status = type !== 'undefined' ? 'âœ… Available' : 'âŒ Not Available';
                log(`${api}: ${status}`);
                apiDiv.innerHTML += `${api}: ${status}\n`;
            });
        }

        function checkContentScript() {
            const statusDiv = document.getElementById('content-script-status');
            statusDiv.innerHTML = '<h4>ì½˜í…ì¸  ìŠ¤í¬ë¦½íŠ¸ ìƒíƒœ</h4>';

            // Check if PopupManager is defined
            const hasPopupManager = typeof PopupManager !== 'undefined';
            updateElement('content-script-status', `PopupManager: ${hasPopupManager ? 'âœ…' : 'âŒ'}`, hasPopupManager ? 'success' : 'error');

            if (hasPopupManager) {
                updateElement('content-script-status', 'PopupManager íƒ€ì…: ' + typeof PopupManager, 'info');
                log('PopupManager found and accessible');
            } else {
                updateElement('content-script-status', 'âŒ PopupManagerë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ - ì½˜í…ì¸  ìŠ¤í¬ë¦½íŠ¸ê°€ ì£¼ì…ë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤', 'error');
                log('PopupManager not found');
            }

            // Check for content script execution
            const scriptTags = Array.from(document.querySelectorAll('script'));
            const hasContentScript = scriptTags.some(script =>
                script.src && script.src.includes('content.js')
            );
            updateElement('content-script-status', `Content.js ìŠ¤í¬ë¦½íŠ¸: ${hasContentScript ? 'âœ…' : 'âŒ'}`, hasContentScript ? 'success' : 'warning');
        }

        function checkPopupManager() {
            const statusDiv = document.getElementById('content-script-status');

            if (typeof PopupManager !== 'undefined') {
                try {
                    // Try to create a PopupManager instance
                    const testManager = new PopupManager();
                    updateElement('content-script-status', 'PopupManager ì¸ìŠ¤í„´ìŠ¤ ìƒì„±: âœ…', 'success');
                    updateElement('content-script-status', `Manager íƒ€ì…: ${typeof testManager}`, 'info');
                    updateElement('content-script-status', `Manager ì†ì„±: ${Object.keys(testManager).join(', ')}`, 'info');
                    log('PopupManager instance created successfully');
                } catch (error) {
                    updateElement('content-script-status', `PopupManager ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì‹¤íŒ¨: ${error.message}`, 'error');
                    log(`PopupManager creation failed: ${error.message}`);
                }
            } else {
                updateElement('content-script-status', 'âŒ PopupManagerê°€ ì •ì˜ë˜ì§€ ì•ŠìŒ', 'error');
            }
        }

        function checkEventListeners() {
            const resultsDiv = document.getElementById('drag-test-results');

            // Setup selection detection
            const handleSelection = (event) => {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();

                if (selectedText.length > 0) {
                    updateElement('drag-test-results', `í…ìŠ¤íŠ¸ ì„ íƒ ê°ì§€: "${selectedText.substring(0, 50)}..."`, 'success');
                    log(`Text selected: ${selectedText}`);

                    // Check if popup would be created
                    if (typeof PopupManager !== 'undefined') {
                        updateElement('drag-test-results', 'PopupManager í˜¸ì¶œ ê°€ëŠ¥: âœ…', 'success');
                    } else {
                        updateElement('drag-test-results', 'PopupManager í˜¸ì¶œ ë¶ˆê°€: âŒ', 'error');
                    }
                }
            };

            document.addEventListener('mouseup', handleSelection, true);
            document.addEventListener('keyup', handleSelection, true);

            updateElement('drag-test-results', 'ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • ì™„ë£Œ - ìœ„ í…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•´ë³´ì„¸ìš”', 'info');
            log('Event listeners setup for selection detection');
        }

        function testMessageToBackground() {
            const resultsDiv = document.getElementById('messaging-results');

            if (typeof chrome !== 'undefined' && chrome.runtime) {
                try {
                    chrome.runtime.sendMessage(
                        { action: 'test' },
                        (response) => {
                            if (chrome.runtime.lastError) {
                                updateElement('messaging-results', `ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: ${chrome.runtime.lastError.message}`, 'error');
                                log(`Message failed: ${chrome.runtime.lastError.message}`);
                            } else {
                                updateElement('messaging-results', `ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ: ${JSON.stringify(response)}`, 'success');
                                log(`Message response: ${JSON.stringify(response)}`);
                            }
                        }
                    );
                } catch (error) {
                    updateElement('messaging-results', `ë©”ì‹œì§€ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜: ${error.message}`, 'error');
                    log(`Message test error: ${error.message}`);
                }
            } else {
                updateElement('messaging-results', 'âŒ Chrome Runtime APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ', 'error');
            }
        }

        function testStorageAPI() {
            const resultsDiv = document.getElementById('messaging-results');

            if (typeof chrome !== 'undefined' && chrome.storage) {
                try {
                    chrome.storage.local.get(['clips'], (result) => {
                        if (chrome.runtime.lastError) {
                            updateElement('messaging-results', `Storage ì ‘ê·¼ ì‹¤íŒ¨: ${chrome.runtime.lastError.message}`, 'error');
                        } else {
                            const clips = result.clips || [];
                            updateElement('messaging-results', `Storage ì ‘ê·¼ ì„±ê³µ: ${clips.length}ê°œ í´ë¦½ ì €ì¥ë¨`, 'success');
                            log(`Storage access successful: ${clips.length} clips found`);
                        }
                    });
                } catch (error) {
                    updateElement('messaging-results', `Storage í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜: ${error.message}`, 'error');
                }
            } else {
                updateElement('messaging-results', 'âŒ Chrome Storage APIë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ', 'error');
            }
        }

        function runFullDiagnostic() {
            log('Starting full diagnostic...');
            clearAllResults();

            checkExtensionStatus();
            checkChromeAPIs();
            checkContentScript();
            checkEventListeners();
            testMessageToBackground();
            testStorageAPI();

            const resultsDiv = document.getElementById('full-diagnostic-results');
            resultsDiv.innerHTML = '<h4>ğŸ” ì „ì²´ ì§„ë‹¨ ì™„ë£Œ</h4>';
            resultsDiv.innerHTML += '<div class="info">ìœ„ì˜ ê° ì„¹ì…˜ì—ì„œ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”</div>';

            log('Full diagnostic completed');
        }

        function clearSelectionTestResults() {
            document.getElementById('drag-test-results').innerHTML = '';
        }

        function clearMessageResults() {
            document.getElementById('messaging-results').innerHTML = '';
        }

        function clearAllResults() {
            const resultIds = ['extension-status', 'api-status', 'content-script-status', 'drag-test-results', 'messaging-results', 'full-diagnostic-results'];
            resultIds.forEach(id => {
                document.getElementById(id).innerHTML = '';
            });
            debugLog = [];
            log('All results cleared');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            log('Debug tool loaded');
            console.log('ğŸ”§ ClipGo Debug Tool loaded');
            console.log('Use the buttons above to diagnose the extension');
        });
    </script>
</body>
</html>