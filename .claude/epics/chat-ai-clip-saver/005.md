---
name: UI Components & Library Interface
status: open
created: 2025-09-29T00:51:27Z
updated: 2025-09-29T00:51:27Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 003, 004]
parallel: true
conflicts_with: []
---
# Task: UI Components & Library Interface
## Description
저장된 클립을 표시하고 관리하는 UI 컴포넌트를 구현합니다. 팝업 인터페이스, 클립 목록 뷰, 상세 정보 표시, 라이브러리 관리 기능을 포함하는 전체 사용자 인터페이스를 개발합니다.
## Acceptance Criteria
### Must-Have
- [ ] **팝업 UI**: 확장 프로그램 팝업에 클립 목록 표시
- [ ] **클립 목록**: 저장된 모든 클립을 목록 형태로 표시
- [ ] **클립 상세**: 각 클립의 텍스트, URL, 타이틀, 타임스탬프 표시
- [ ] **검색 기능**: 클립 내용을 키워드로 검색하는 기능
- [ ] **삭제 기능**: 불필요한 클립을 삭제하는 기능
- [ ] **외부 라이브러리 통합**: SortableJS를 활용한 재정렬 기능
### Nice-to-Have
- [ ] **태그 시스템**: 클립에 태그를 추가하고 관리하는 기능
- [ ] **필터링**: 태그, 날짜, 소스별로 클립을 필터링하는 기능
- [ ] **정렬 옵션**: 날짜, 텍스트 길이, 타이틀 등으로 정렬하는 기능
- [ ] **다크 모드**: 다크 모드 테마 지원
## Implementation Details
### HTML 구조
```html
<!-- popup.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Clipgo - AI Clip Saver</title>
    <link rel="stylesheet" href="popup.css">
    <link rel="stylesheet" href="lib/sortablejs/Sortable.min.css">
</head>
<body>
    <div class="popup-container">
        <header class="popup-header">
            <h1>Clipgo Library</h1>
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="Search clips...">
                <button id="clearSearch">Clear</button>
            </div>
        </header>
        <main class="popup-content">
            <div class="filter-bar">
                <select id="sortBy">
                    <option value="date">Sort by Date</option>
                    <option value="title">Sort by Title</option>
                    <option value="text">Sort by Text</option>
                </select>
                <button id="addTag">Add Tag</button>
            </div>
            <div id="clipList" class="clip-list sortable-list">
                <!-- Clips will be dynamically inserted here -->
            </div>
            <div id="emptyState" class="empty-state">
                <p>No clips saved yet. Select text on any webpage to get started!</p>
            </div>
        </main>
        <footer class="popup-footer">
            <div class="stats">
                <span id="clipCount">0 clips</span>
            </div>
            <div class="actions">
                <button id="clearAll">Clear All</button>
                <button id="exportData">Export</button>
            </div>
        </footer>
    </div>
    <script src="lib/sortablejs/Sortable.min.js"></script>
    <script src="popup.js"></script>
</body>
</html>
```
### CSS 스타일링
```css
/* popup.css */
.popup-container {
    width: 400px;
    min-height: 500px;
    max-height: 600px;
    display: flex;
    flex-direction: column;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
.popup-header {
    padding: 16px;
    border-bottom: 1px solid #e0e0e0;
    background-color: #f8f9fa;
}
.popup-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}
.clip-list {
    list-style: none;
    padding: 0;
    margin: 0;
}
.clip-item {
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    cursor: move;
    transition: all 0.2s ease;
}
.clip-item:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.clip-item.dragging {
    opacity: 0.5;
}
.clip-text {
    font-size: 14px;
    line-height: 1.4;
    margin-bottom: 8px;
    word-wrap: break-word;
}
.clip-meta {
    font-size: 12px;
    color: #666;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.clip-url {
    color: #0066cc;
    text-decoration: none;
    font-size: 11px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 200px;
}
```
### JavaScript 로직
```javascript
// popup.js
class ClipLibrary {
    constructor() {
        this.clips = [];
        this.sortable = null;
        this.initializeUI();
        this.loadClips();
        this.setupEventListeners();
        this.initializeSortable();
    }
    async loadClips() {
        try {
            const result = await chrome.storage.local.get(['clips']);
            this.clips = result.clips || [];
            this.renderClips();
            this.updateStats();
        } catch (error) {
            console.error('Error loading clips:', error);
        }
    }
    renderClips() {
        const clipList = document.getElementById('clipList');
        const emptyState = document.getElementById('emptyState');
        if (this.clips.length === 0) {
            clipList.style.display = 'none';
            emptyState.style.display = 'block';
            return;
        }
        clipList.style.display = 'block';
        emptyState.style.display = 'none';
        clipList.innerHTML = this.clips.map(clip => this.createClipElement(clip)).join('');
    }
    createClipElement(clip) {
        const date = new Date(clip.timestamp).toLocaleDateString();
        return `
            <div class="clip-item" data-id="${clip.id}">
                <div class="clip-text">${this.escapeHtml(clip.text)}</div>
                <div class="clip-meta">
                    <span class="clip-date">${date}</span>
                    <a href="${clip.url}" target="_blank" class="clip-url" title="${clip.title}">
                        ${clip.title}
                    </a>
                    <button class="delete-btn" data-id="${clip.id}">Delete</button>
                </div>
            </div>
        `;
    }
    initializeSortable() {
        const clipList = document.getElementById('clipList');
        this.sortable = Sortable.create(clipList, {
            animation: 150,
            ghostClass: 'sortable-ghost',
            onEnd: (evt) => {
                this.reorderClips(evt.oldIndex, evt.newIndex);
            }
        });
    }
    async reorderClips(oldIndex, newIndex) {
        const movedClip = this.clips.splice(oldIndex, 1)[0];
        this.clips.splice(newIndex, 0, movedClip);
        await chrome.storage.local.set({ clips: this.clips });
    }
    setupEventListeners() {
        // Search functionality
        document.getElementById('searchInput').addEventListener('input', (e) => {
            this.filterClips(e.target.value);
        });
        // Delete functionality
        document.getElementById('clipList').addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-btn')) {
                this.deleteClip(e.target.dataset.id);
            }
        });
        // Sort functionality
        document.getElementById('sortBy').addEventListener('change', (e) => {
            this.sortClips(e.target.value);
        });
    }
    filterClips(searchTerm) {
        const filtered = this.clips.filter(clip =>
            clip.text.toLowerCase().includes(searchTerm.toLowerCase()) ||
            clip.title.toLowerCase().includes(searchTerm.toLowerCase())
        );
        this.renderFilteredClips(filtered);
    }
    sortClips(sortBy) {
        switch (sortBy) {
            case 'date':
                this.clips.sort((a, b) => b.timestamp - a.timestamp);
                break;
            case 'title':
                this.clips.sort((a, b) => a.title.localeCompare(b.title));
                break;
            case 'text':
                this.clips.sort((a, b) => a.text.localeCompare(b.text));
                break;
        }
        this.renderClips();
    }
    async deleteClip(clipId) {
        this.clips = this.clips.filter(clip => clip.id !== clipId);
        await chrome.storage.local.set({ clips: this.clips });
        this.renderClips();
        this.updateStats();
    }
    updateStats() {
        document.getElementById('clipCount').textContent = `${this.clips.length} clips`;
    }
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}
// Initialize the library when popup opens
document.addEventListener('DOMContentLoaded', () => {
    new ClipLibrary();
});
```
## Dependencies
### 외부 의존성
- SortableJS 라이브러리 (드래그 & 드롭 기능)
- Chrome Extensions API (storage, runtime)
- CSS3 for styling and animations
### 내부 의존성
- Task 001: Project Structure & Manifest Setup
- Task 003: Basic Extension Architecture
- Task 004: Clip Management System (Text Selection & Saving)
## Technical Notes
### 성능 최적화
- 가상 스크롤링 대신 페이지네이션 구현 (클립 수가 많을 경우)
- CSS transform을 활용한 애니메이션 최적화
- 이벤트 위임을 통한 메모리 사용량 감소
### 접근성
- 키보드 내비게이션 지원
- 스크린 리더 호환성
- 대비율 및 가독성 최적화
### 반응형 디자인
- 다양한 팝업 크기에 대응하는 유연한 레이아웃
- 모바일 환경에서의 터치 인터랙션 지원
## Success Criteria
### 기술적 성공 기준
- [ ] 팝업이 정상적으로 열리고 클립 목록이 표시됨
- [ ] 클립 추가/삭제가 즉시 UI에 반영됨
- [ ] 검색 기능이 실시간으로 작동함
- [ ] SortableJS를 통한 드래그 & 드롭이 정상적으로 작동함
- [ ] Chrome Storage와의 데이터 동기화가 정상적으로 작동함
### 품질 기준
- [ ] UI 로딩 시간이 500ms 미만으로 유지됨
- [ ] 100개 이상의 클립이 있을 때도 성능 저하가 없음
- [ ] 모든 버튼과 인터랙션이 정상적으로 작동함
- [ ] 디자인이 일관되고 사용자 친화적임
- [ ] 에러 상황에서 적절한 사용자 피드백이 제공됨