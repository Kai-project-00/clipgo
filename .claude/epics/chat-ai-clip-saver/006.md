---
name: Drag & Drop Implementation
status: open
created: 2025-09-29T00:51:27Z
updated: 2025-09-29T00:51:27Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 003, 004, 005]
parallel: true
conflicts_with: []
---
# Task: Drag & Drop Implementation
## Description
SortableJS 라이브러리를 통한 고급 드래그 & 드롭 기능을 구현합니다. 클립 재정렬, 그룹화, 외부 애플리케이션으로의 드래그 & 드롭 등 다양한 드래그 & 드롭 인터랙션을 지원하는 기능을 개발합니다.
## Acceptance Criteria
### Must-Have
- [ ] **SortableJS 통합**: SortableJS 라이브러리 프로젝트 통합
- [ ] **클립 재정렬**: 클립 목록 내에서 클립을 드래그하여 순서 변경
- [ ] **시각적 피드백**: 드래그 중인 클립의 시각적 표시 및 위치 표시
- [ ] **자동 저장**: 재정렬된 순서가 Chrome Storage에 자동 저장
- [ ] **멀티 드래그**: 여러 클립을 동시에 선택하고 드래그하는 기능
### Nice-to-Have
- [ ] **외부 드래그**: 클립을 팝업 외부로 드래그하여 텍스트 복사
- [ ] **그룹화**: 관련 클립을 그룹으로 묶는 기능
- [ ] **애니메이션**: 부드러운 드래그 & 드롭 애니메이션
- [ ] **터치 지원**: 모바일 환경에서의 터치 드래그 지원
## Implementation Details
### SortableJS 초기화
```javascript
// popup.js - SortableJS 초기화
initializeSortable() {
    const clipList = document.getElementById('clipList');
    this.sortable = Sortable.create(clipList, {
        animation: 150,
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        dragClass: 'sortable-drag',
        handle: '.clip-item',
        multiDrag: true,  // 멀티 드래그 지원
        selectedClass: 'sortable-selected',
        dataIdAttr: 'data-id',
        // 드래그 시작 시
        onStart: (evt) => {
            this.onDragStart(evt);
        },
        // 드래그 종료 시
        onEnd: (evt) => {
            this.onDragEnd(evt);
        },
        // 멀티 선택 시
        onSelect: (evt) => {
            this.onMultiSelect(evt);
        },
        // 멀티 선택 해제 시
        onDeselect: (evt) => {
            this.onMultiDeselect(evt);
        },
        // 요소 변경 시
        onChange: (evt) => {
            this.onDragChange(evt);
        }
    });
}
```
### 드래그 이벤트 핸들러
```javascript
// 드래그 시작
onDragStart(evt) {
    this.isDragging = true;
    document.body.classList.add('dragging');
    // 드래그 중인 클립 정보 저장
    this.draggedClips = this.getSelectedClips();
    // 시각적 피드백
    evt.item.classList.add('dragging');
    // 외부 드래그를 위한 데이터 설정
    if (this.draggedClips.length === 1) {
        evt.item.draggable = true;
        evt.item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', this.draggedClips[0].text);
            e.dataTransfer.setData('application/x-clipgo', JSON.stringify(this.draggedClips[0]));
        });
    }
}
// 드래그 종료
async onDragEnd(evt) {
    this.isDragging = false;
    document.body.classList.remove('dragging');
    evt.item.classList.remove('dragging');
    // 순서 업데이트
    await this.updateClipOrder();
    // 변경 사항 저장
    await this.saveClipOrder();
    // 통계 업데이트
    this.updateStats();
}
// 멀티 선택
onMultiSelect(evt) {
    const selectedItems = this.sortable.getSelectedItems();
    this.updateMultiSelectUI(selectedItems);
}
// 멀티 선택 해제
onMultiDeselect(evt) {
    const selectedItems = this.sortable.getSelectedItems();
    this.updateMultiSelectUI(selectedItems);
}
```
### CSS 스타일링
```css
/* popup.css - 드래그 & 드롭 관련 스타일 */
.sortable-ghost {
    opacity: 0.4;
    background: #f8f9fa;
    border: 2px dashed #007bff;
}
.sortable-chosen {
    background: #e3f2fd;
    border-color: #2196f3;
}
.sortable-drag {
    opacity: 0.8;
    transform: rotate(2deg);
    box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    z-index: 1000;
}
.sortable-selected {
    background: #e8f5e8;
    border-color: #4caf50;
}
.clip-item.dragging {
    cursor: grabbing;
    transform: scale(1.02);
    z-index: 999;
}
/* 드래그 중 전체 배경 */
body.dragging {
    background-color: #f0f8ff;
    transition: background-color 0.3s ease;
}
/* 드래그 위치 표시기 */
.drag-placeholder {
    height: 4px;
    background: #007bff;
    border-radius: 2px;
    margin: 8px 0;
    animation: pulse 1s infinite;
}
@keyframes pulse {
    0% { opacity: 0.3; }
    50% { opacity: 0.8; }
    100% { opacity: 0.3; }
}
/* 멀티 선택 컨트롤 */
.multi-select-controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    display: none;
    z-index: 1001;
}
.multi-select-controls.active {
    display: block;
}
.multi-select-controls button {
    margin: 0 5px;
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    background: #007bff;
    color: white;
    cursor: pointer;
}
.multi-select-controls button:hover {
    background: #0056b3;
}
```
### 외부 드래그 & 드롭 기능
```javascript
// 외부 애플리케이션으로 드래그
setupExternalDrag() {
    const clipList = document.getElementById('clipList');
    clipList.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('clip-item')) {
            const clipId = e.target.dataset.id;
            const clip = this.clips.find(c => c.id === clipId);
            if (clip) {
                // 텍스트 데이터
                e.dataTransfer.setData('text/plain', clip.text);
                // 커스텀 데이터
                e.dataTransfer.setData('application/x-clipgo', JSON.stringify(clip));
                // 드래그 이미지 설정
                const dragImage = this.createDragImage(clip);
                e.dataTransfer.setDragImage(dragImage, 0, 0);
            }
        }
    });
    // 드래그 이미지 생성
    createDragImage(clip) {
        const div = document.createElement('div');
        div.style.cssText = `
            position: absolute;
            top: -1000px;
            left: -1000px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-family: sans-serif;
            font-size: 14px;
            max-width: 300px;
            word-wrap: break-word;
        `;
        div.textContent = clip.text.length > 100 ? clip.text.substring(0, 100) + '...' : clip.text;
        document.body.appendChild(div);
        // 일정 시간 후 제거
        setTimeout(() => {
            document.body.removeChild(div);
        }, 100);
        return div;
    }
}
```
### 클립 순서 관리
```javascript
// 클립 순서 업데이트
updateClipOrder() {
    const clipList = document.getElementById('clipList');
    const newOrder = Array.from(clipList.children).map(item => {
        return item.dataset.id;
    });
    // 새로운 순서에 따라 클립 배열 재정렬
    const reorderedClips = [];
    newOrder.forEach(id => {
        const clip = this.clips.find(c => c.id === id);
        if (clip) {
            reorderedClips.push(clip);
        }
    });
    this.clips = reorderedClips;
}
// 순서 저장
async saveClipOrder() {
    try {
        await chrome.storage.local.set({ clips: this.clips });
        console.log('Clip order saved successfully');
    } catch (error) {
        console.error('Error saving clip order:', error);
        this.showError('Failed to save clip order');
    }
}
```
## Dependencies
### 외부 의존성
- SortableJS 라이브러리 (핵심 드래그 & 드롭 기능)
- Chrome Extensions API (storage for persistence)
- HTML5 Drag and Drop API (외부 드래그 기능)
### 내부 의존성
- Task 001: Project Structure & Manifest Setup
- Task 003: Basic Extension Architecture
- Task 004: Clip Management System (Text Selection & Saving)
- Task 005: UI Components & Library Interface
## Technical Notes
### 성능 최적화
- 가상 리스트를 통한 대규모 클립 목록 처리
- CSS transform을 활용한 하드웨어 가속
- 이벤트 디바운싱을 통한 불필요한 렌더링 방지
### 접근성
- 키보드 내비게이션 지원 (Tab, Space, Arrow keys)
- 스크린 리더 호환성 (ARIA 라벨 및 속성)
- 고대비 모드 지원
### 호환성
- 다양한 브라우저 환경에서의 테스트
- 터치 디바이스 지원
- 다양한 화면 크기에 대한 반응형 디자인
## Success Criteria
### 기술적 성공 기준
- [ ] SortableJS가 성공적으로 통합되고 초기화됨
- [ ] 단일 클립 드래그 & 드롭이 정상적으로 작동함
- [ ] 멀티 클립 선택 및 드래그가 정상적으로 작동함
- [ ] 드래그 순서 변경이 Chrome Storage에 저장됨
- [ ] 외부 애플리케이션으로의 드래그가 작동함
- [ ] 시각적 피드백이 적절하게 제공됨
### 품질 기준
- [ ] 드래그 & 드롭 인터랙션이 부드럽고 반응적임
- [ ] 다양한 클립 수(1~100개)에서 성능 저하가 없음
- [ ] 모바일 터치 환경에서 정상적으로 작동함
- [ ] 키보드 내비게이션이 지원됨
- [ ] 드래그 중 UI가 깨지거나 버그가 발생하지 않음
- [ ] 사용자가 직관적으로 인터페이스를 이해하고 사용할 수 있음