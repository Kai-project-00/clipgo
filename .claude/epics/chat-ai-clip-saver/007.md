---
name: Internationalization (i18n) System
status: open
created: 2025-09-29T00:51:27Z
updated: 2025-09-29T00:51:27Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 003, 005]
parallel: true
conflicts_with: []
---
# Task: Internationalization (i18n) System
## Description
Chrome Extension의 다국어 지원 시스템을 구현합니다. 한국어와 영어를 기본으로 하여, 사용자가 언어를 전환할 수 있는 기능을 제공합니다. 텍스트 라벨, 메시지, 알림 등 모든 사용자 인터페이스 요소에 다국어를 적용합니다.
## Acceptance Criteria
### Must-Have
- [ ] **i18n 모듈 구현**: 언어 관리 및 번역 기능을 담당하는 I18nManager 클래스
- [ ] **번역 파일 구조**: 한국어(ko.json)와 영어(en.json) 번역 파일
- [ ] **언어 전환 기능**: 설정에서 언어 선택 및 즉시 적용
- [ ] **UI 텍스트 다국화**: 모든 버튼, 라벨, 메시지의 다국어 적용
- [ ] **Chrome API 호환**: chrome.i18n API와의 통합
### Nice-to-Have
- [ ] **다크모드 테마**: 다크/라이트 모드 전환 기능
- [ ] **RTL 언어 지원**: 아랍어 등 오른쪽에서 왼쪽으로 쓰는 언어 지원 준비
- [ ] **브라우저 언어 자동 감지**: 사용자 브라우저 언어 설정에 따른 자동 선택
- [ ] **번역 가이드라인**: 추가 언어 번역을 위한 가이드 문서
## Implementation Details
### I18nManager 클래스 구현
```javascript
// popup.js - I18nManager 클래스
class I18nManager {
    constructor() {
        this.currentLanguage = 'ko';
        this.translations = {};
        this.fallbackLanguage = 'en';
        this.initialized = false;
    }
    // 초기화
    async initialize() {
        try {
            // 저장된 언어 설정 로드
            const result = await chrome.storage.local.get(['settings']);
            this.currentLanguage = result.settings?.language || this.detectBrowserLanguage();
            // 번역 파일 로드
            await this.loadTranslations();
            // DOM 업데이트
            this.updateDOM();
            // 이벤트 리스너 설정
            this.setupEventListeners();
            this.initialized = true;
            console.log('I18n system initialized with language:', this.currentLanguage);
        } catch (error) {
            console.error('Failed to initialize i18n:', error);
            this.currentLanguage = 'en'; // Fallback
        }
    }
    // 브라우저 언어 감지
    detectBrowserLanguage() {
        const browserLang = navigator.language.toLowerCase();
        return browserLang.startsWith('ko') ? 'ko' : 'en';
    }
    // 번역 파일 로드
    async loadTranslations() {
        try {
            const [koTranslations, enTranslations] = await Promise.all([
                this.loadTranslationFile('ko'),
                this.loadTranslationFile('en')
            ]);
            this.translations = {
                ko: koTranslations,
                en: enTranslations
            };
        } catch (error) {
            console.error('Failed to load translations:', error);
            throw error;
        }
    }
    // 개별 번역 파일 로드
    async loadTranslationFile(lang) {
        const response = await fetch(`_locales/${lang}/messages.json`);
        if (!response.ok) {
            throw new Error(`Failed to load ${lang} translations`);
        }
        return response.json();
    }
    // 언어 변경
    async setLanguage(lang) {
        if (this.translations[lang]) {
            this.currentLanguage = lang;
            // 설정 저장
            await chrome.storage.local.set({
                settings: { ...await this.getSettings(), language: lang }
            });
            // DOM 업데이트
            this.updateDOM();
            // 이벤트 발생
            this.emit('languageChanged', { language: lang });
        }
    }
    // 텍스트 번역
    translate(key, params = {}) {
        const translation = this.translations[this.currentLanguage]?.[key] ||
                          this.translations[this.fallbackLanguage]?.[key] ||
                          key;
        // 파라미터 치환
        return this.interpolate(translation, params);
    }
    // 파라미터 치환
    interpolate(text, params) {
        return text.replace(/\{\{(\w+)\}\}/g, (match, key) => {
            return params[key] !== undefined ? params[key] : match;
        });
    }
    // DOM 업데이트
    updateDOM() {
        // data-i18n 속성이 있는 모든 요소 업데이트
        document.querySelectorAll('[data-i18n]').forEach(element => {
            const key = element.getAttribute('data-i18n');
            const translation = this.translate(key);
            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                element.placeholder = translation;
            } else {
                element.textContent = translation;
            }
        });
        // data-i18n-title 속성이 있는 요소의 툴팁 업데이트
        document.querySelectorAll('[data-i18n-title]').forEach(element => {
            const key = element.getAttribute('data-i18n-title');
            element.title = this.translate(key);
        });
        // data-i18n-html 속성이 있는 요소의 HTML 업데이트
        document.querySelectorAll('[data-i18n-html]').forEach(element => {
            const key = element.getAttribute('data-i18n-html');
            element.innerHTML = this.translate(key);
        });
    }
    // 이벤트 리스너 설정
    setupEventListeners() {
        // 언어 선택 변경 감지
        const languageSelect = document.getElementById('languageSelect');
        if (languageSelect) {
            languageSelect.addEventListener('change', (e) => {
                this.setLanguage(e.target.value);
            });
        }
    }
    // 설정 가져오기
    async getSettings() {
        const result = await chrome.storage.local.get(['settings']);
        return result.settings || {};
    }
    // 이벤트 발생
    emit(event, data) {
        const customEvent = new CustomEvent(event, { detail: data });
        document.dispatchEvent(customEvent);
    }
}
```
### 번역 파일 구조
```json
// _locales/ko/messages.json
{
    "extensionName": {
        "message": "ClipGo"
    },
    "extensionDescription": {
        "message": "AI 대화 클립 저장 관리자"
    },
    "saveClip": {
        "message": "클립 저장"
    },
    "categories": {
        "message": "카테고리"
    },
    "allClips": {
        "message": "모든 클립"
    },
    "search": {
        "message": "검색"
    },
    "settings": {
        "message": "설정"
    },
    "language": {
        "message": "언어"
    },
    "theme": {
        "message": "테마"
    },
    "lightTheme": {
        "message": "라이트 모드"
    },
    "darkTheme": {
        "message": "다크 모드"
    },
    "noClips": {
        "message": "저장된 클립이 없습니다"
    },
    "clipSaved": {
        "message": "클립이 저장되었습니다"
    },
    "clipDeleted": {
        "message": "클립이 삭제되었습니다"
    },
    "categoryCreated": {
        "message": "카테고리가 생성되었습니다"
    },
    "categoryDeleted": {
        "message": "카테고리가 삭제되었습니다"
    },
    "selectTextToSave": {
        "message": "저장할 텍스트를 선택하세요"
    },
    "newCategory": {
        "message": "새 카테고리"
    },
    "editCategory": {
        "message": "카테고리 편집"
    },
    "deleteCategory": {
        "message": "카테고리 삭제"
    },
    "deleteConfirmation": {
        "message": "정말 삭제하시겠습니까?"
    },
    "cancel": {
        "message": "취소"
    },
    "confirm": {
        "message": "확인"
    },
    "dragToReorder": {
        "message": "드래그하여 순서 변경"
    },
    "copyToClipboard": {
        "message": "클립보드에 복사"
    },
    "editClip": {
        "message": "클립 편집"
    },
    "deleteClip": {
        "message": "클립 삭제"
    },
    "source": {
        "message": "출처"
    },
    "savedAt": {
        "message": "저장 시간"
    },
    "wordCount": {
        "message": "단어 수"
    },
    "characterCount": {
        "message": "글자 수"
    }
}
```
### HTML에서의 다국어 사용
```html
<!-- popup.html -->
<div class="header">
    <h1 data-i18n="extensionName">ClipGo</h1>
    <select id="languageSelect" class="language-select">
        <option value="ko">한국어</option>
        <option value="en">English</option>
    </select>
</div>
<div class="sidebar">
    <h2 data-i18n="categories">카테고리</h2>
    <button class="btn-new-category" data-i18n-title="newCategory">
        <span class="icon">+</span>
    </button>
    <div id="categoryTree"></div>
</div>
<div class="main-content">
    <div class="toolbar">
        <input type="text" id="searchInput" data-i18n-placeholder="search" placeholder="검색">
        <button id="saveClipBtn" data-i18n="saveClip">클립 저장</button>
    </div>
    <div id="clipList" class="clip-list">
        <div class="empty-state" data-i18n="noClips">저장된 클립이 없습니다</div>
    </div>
</div>
```
### 테마 관리 시스템
```javascript
// 테마 관리자
class ThemeManager {
    constructor(i18nManager) {
        this.i18nManager = i18nManager;
        this.currentTheme = 'light';
        this.initialized = false;
    }
    async initialize() {
        try {
            // 저장된 테마 설정 로드
            const result = await chrome.storage.local.get(['settings']);
            this.currentTheme = result.settings?.theme || 'light';
            // 테마 적용
            this.applyTheme();
            // 이벤트 리스너 설정
            this.setupEventListeners();
            this.initialized = true;
        } catch (error) {
            console.error('Failed to initialize theme manager:', error);
        }
    }
    applyTheme() {
        document.documentElement.setAttribute('data-theme', this.currentTheme);
        document.body.classList.toggle('dark-theme', this.currentTheme === 'dark');
    }
    async setTheme(theme) {
        this.currentTheme = theme;
        // 설정 저장
        await chrome.storage.local.set({
            settings: { ...await this.getSettings(), theme: theme }
        });
        // 테마 적용
        this.applyTheme();
        // 이벤트 발생
        this.emit('themeChanged', { theme });
    }
    setupEventListeners() {
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
            themeSelect.addEventListener('change', (e) => {
                this.setTheme(e.target.value);
            });
        }
    }
    async getSettings() {
        const result = await chrome.storage.local.get(['settings']);
        return result.settings || {};
    }
    emit(event, data) {
        const customEvent = new CustomEvent(event, { detail: data });
        document.dispatchEvent(customEvent);
    }
}
```
### CSS 변수를 활용한 테마 시스템
```css
/* popup.css - CSS 변수 기반 테마 */
:root {
    /* 라이트 모드 기본 색상 */
    --bg-primary: #ffffff;
    --bg-secondary: #f8f9fa;
    --bg-tertiary: #e9ecef;
    --text-primary: #212529;
    --text-secondary: #6c757d;
    --border-color: #dee2e6;
    --shadow-color: rgba(0, 0, 0, 0.1);
    --accent-color: #007bff;
    --accent-hover: #0056b3;
    --success-color: #28a745;
    --danger-color: #dc3545;
    --warning-color: #ffc107;
}
/* 다크 모드 색상 */
[data-theme="dark"] {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-tertiary: #404040;
    --text-primary: #ffffff;
    --text-secondary: #b0b0b0;
    --border-color: #404040;
    --shadow-color: rgba(0, 0, 0, 0.3);
    --accent-color: #4dabf7;
    --accent-hover: #339af0;
    --success-color: #51cf66;
    --danger-color: #ff6b6b;
    --warning-color: #ffd43b;
}
/* 테마 적용 예시 */
body {
    background-color: var(--bg-primary);
    color: var(--text-primary);
    transition: background-color 0.3s ease, color 0.3s ease;
}
.clip-item {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    color: var(--text-primary);
}
.clip-item:hover {
    background-color: var(--bg-tertiary);
}
.btn-primary {
    background-color: var(--accent-color);
    color: white;
}
.btn-primary:hover {
    background-color: var(--accent-hover);
}
.sidebar {
    background-color: var(--bg-secondary);
    border-right: 1px solid var(--border-color);
}
```
### 설정 페이지 다국어
```html
<!-- 설정 페이지 -->
<div class="settings-page">
    <h2 data-i18n="settings">설정</h2>
    <div class="setting-group">
        <label for="languageSelect" data-i18n="language">언어</label>
        <select id="languageSelect" class="form-select">
            <option value="ko">한국어</option>
            <option value="en">English</option>
        </select>
    </div>
    <div class="setting-group">
        <label for="themeSelect" data-i18n="theme">테마</label>
        <select id="themeSelect" class="form-select">
            <option value="light" data-i18n="lightTheme">라이트 모드</option>
            <option value="dark" data-i18n="darkTheme">다크 모드</option>
        </select>
    </div>
</div>
```
## Dependencies
### 외부 의존성
- Chrome Extensions API (storage, i18n)
- ES6+ JavaScript features
- CSS Custom Properties
### 내부 의존성
- Task 001: Project Structure & Manifest Setup
- Task 003: Basic Extension Architecture
- Task 005: UI Components & Library Interface
## Technical Notes
### Chrome i18n API 통합
- `chrome.i18n.getMessage()`를 활용한 번역
- `_locales` 디렉토리 구조 준수
- 브라우저 기본 언어 감지 기능
### 성능 최적화
- 번역 파일을 한번만 로드하고 캐싱
- DOM 업데이트는 필요한 경우에만 수행
- 이벤트 디바운싱을 통한 불필요한 업데이트 방지
### 접근성
- 언어 변경 시 스크린 리더 호환성
- 고대비 모드 지원
- 키보드 내비게이션 지원
## Success Criteria
### 기술적 성공 기준
- [ ] 한국어와 영어 간 전환이 정상적으로 작동함
- [ ] 모든 UI 텍스트가 번역되고 표시됨
- [ ] 언어 설정이 저장되고 유지됨
- [ ] 다크/라이트 모드 전환이 작동함
- [ ] Chrome i18n API와 호환됨
### 품질 기준
- [ ] 번역이 자연스럽고 일관성 있음
- [ ] 테마 전환이 부드럽고 깜빡임이 없음
- [ ] 모든 언어에서 UI 레이아웃이 깨지지 않음
- [ ] 다국어 전환 시 데이터 손실이 없음
- [ ] 성능 저하가 발생하지 않음